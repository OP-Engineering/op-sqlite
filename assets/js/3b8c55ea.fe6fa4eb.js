"use strict";(self.webpackChunkop_sqlite=self.webpackChunkop_sqlite||[]).push([[803],{23:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"installation","title":"Installation","description":"Installing is easy","source":"@site/docs/installation.md","sourceDirName":".","slug":"/installation","permalink":"/op-sqlite/docs/installation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/installation.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","next":{"title":"Configuration","permalink":"/op-sqlite/docs/configuration"}}');var s=i(4848),t=i(8453);const l={sidebar_position:1},r="Installation",a={},d=[{value:"Expo Updates",id:"expo-updates",level:2},{value:"Libsql",id:"libsql",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"installation",children:"Installation"})}),"\n",(0,s.jsx)(n.p,{children:"Installing is easy"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"npm i -s @op-engineering/op-sqlite && npx pod-install\n"})}),"\n",(0,s.jsx)(n.h1,{id:"configuration",children:"Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["SQLite is very customizable on compilation level. op-sqlite also allows you add extensions or even change the base implementation. You can do this by adding the following to your ",(0,s.jsx)(n.code,{children:"package.json"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  // ... the rest of your package.json\n  // All the keys are optional, see the usage below\n  "op-sqlite": {\n    "sqlcipher": false\n    // "crsqlite": false,\n    // "performanceMode": true,\n    // "iosSqlite": false,\n    // "sqliteFlags": "-DSQLITE_DQS=0",\n    // "fts5": true,\n    // "rtree": true,\n    // "libsql": true,\n    // "sqliteVec": true,\n    // "tokenizers": ["simple_tokenizer"]\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"All keys are optional, only turn on the features you want:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sqlcipher"})," allows to change the base sqlite implementation to ",(0,s.jsx)(n.a,{href:"https://www.zetetic.net/sqlcipher/",children:"sqlcipher"}),", which encrypts all the database data with minimal overhead. You will still need to keep your encryption key secure. Read more about security in React Native ",(0,s.jsx)(n.a,{href:"https://ospfranco.com/react-native-security-guide/",children:"here"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"crsqlite"})," is an extension that allows replication to a server backed sqlite database copy. ",(0,s.jsx)(n.a,{href:"https://github.com/vlcn-io/cr-sqlite",children:"Repo here"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"performanceMode"})," turns on certain compilation flags that make sqlite speedier at the cost of disabling some features. You should almost always turn this on, but test your app thoroughly."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"iosSqlite"})," uses the embedded iOS version from sqlite, which saves disk space but may use an older version and cannot load extensions as Apple disables it due to security concerns. On Android SQLite is always compiled from source as each vendor messes with sqlite or uses outdated versions."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sqliteFlags"})," allows you to pass your own compilation flags to further disable/enable features and extensions. It follows the C flag format: ",(0,s.jsx)(n.code,{children:"-D[YOUR_FLAG]=[YOUR_VALUE]"}),". If you are running large queries on large databases sometimes on Android devices you might get a IO exception. You can disable temporary files by using adding the ",(0,s.jsx)(n.code,{children:'"-DSQLITE_TEMP_STORE=2"'})," flag."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"fts5"})," enables the full ",(0,s.jsx)(n.a,{href:"https://www.sqlite.org/fts5.html",children:"text search extension"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tokenizers"})," allows you to write your own C tokenizers. Read more in the corresponding section in this documentation."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"rtree"})," enables the ",(0,s.jsx)(n.a,{href:"https://www.sqlite.org/rtree.html",children:"rtree extension"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sqliteVec"})," enables ",(0,s.jsx)(n.a,{href:"https://github.com/asg017/sqlite-vec",children:"sqlite-vec"}),", an extension for RAG embeddings"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Some combination of features are not allowed. For example ",(0,s.jsx)(n.code,{children:"sqlcipher"})," and ",(0,s.jsx)(n.code,{children:"iosSqlite"})," since they are fundamentally different sources. In this cases you will get an error while doing a pod install or during the Android build."]}),"\n",(0,s.jsx)(n.h1,{id:"ios-pods-use_frameworks-breaks-op-sqlite-",children:"\ud83d\udea8\ud83d\udea8\ud83d\udea8\xa0IOS PODS USE_FRAMEWORKS BREAKS OP-SQLITE \ud83d\udea8\ud83d\udea8\ud83d\udea8"}),"\n",(0,s.jsxs)(n.p,{children:["In case you are using ",(0,s.jsx)(n.code,{children:"use_frameworks"})," (for example because you are using ",(0,s.jsx)(n.code,{children:"react-native-firebase"}),"), this will break the compilation process and force the compilation to use the embedded sqlite on iOS. One possible workaround is putting this in your ",(0,s.jsx)(n.code,{children:"Podfile"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"pre_install do |installer|\n  installer.pod_targets.each do |pod|\n    if pod.name.eql?('op-sqlite')\n      def pod.build_type\n        Pod::BuildType.static_library\n      end\n    end\n  end\nend\n"})}),"\n",(0,s.jsxs)(n.p,{children:["It forces static compilation on ",(0,s.jsx)(n.code,{children:"op-sqlite"})," only. Since everything is compiled from sources this ",(0,s.jsx)(n.em,{children:"should"})," work, however do it at your own risk since other compilation errors might arise. It is possible you will not get any error, but you will not be using the latest version of sqlite but rather the OS embedded one."]}),"\n",(0,s.jsx)(n.h1,{id:"compilation-clashes",children:"Compilation Clashes"}),"\n",(0,s.jsx)(n.p,{children:"If you have other packages that are dependent on sqlite you will have issues."}),"\n",(0,s.jsx)(n.p,{children:"Some of the known offenders are:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"expo-updates"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"expo-sqlite"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"cozodb"})}),"\n",(0,s.jsx)(n.li,{children:"Any other package that might depend on sqlite"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"expo-updates",children:"Expo Updates"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expo-updates"})," now has a added a new way to avoid a hard dependency on sqlite. Adding\xa0",(0,s.jsx)(n.code,{children:'"expo.updates.useThirdPartySQLitePod": "true"'}),"\xa0to\xa0",(0,s.jsx)(n.code,{children:"ios/Podfile.properties.json"}),"\xa0fixes the duplicate symbols and header definition issues when\xa0",(0,s.jsx)(n.code,{children:"expo-updates"}),"\xa0is the only conflicting package."]}),"\n",(0,s.jsx)(n.p,{children:"An expo plugin can also be used:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import type { ConfigPlugin } from '@expo/config-plugins';\nimport { withPodfileProperties } from '@expo/config-plugins';\n\nconst withUseThirdPartySQLitePod: ConfigPlugin<never> = (expoConfig) => {\n  return withPodfileProperties(expoConfig, (config) => {\n    config.modResults = {\n      ...config.modResults,\n      'expo.updates.useThirdPartySQLitePod': 'true',\n    };\n    return config;\n  });\n};\n\nexport default withUseThirdPartySQLitePod;\n"})}),"\n",(0,s.jsx)(n.p,{children:"If you cannot remove the dependency each of the packages will try to compile sqlite from sources or link it on build time. Even if they manage to compile, they might compile sqlite with different compilation flags and you might face runtime errors."}),"\n",(0,s.jsxs)(n.p,{children:["Another workaround for ",(0,s.jsx)(n.code,{children:"expo-updates"})," and ",(0,s.jsx)(n.code,{children:"expo-sqlite"})," you can use the iOS embedded version of sqlite (they both use the OS version, that\u2019s why they clash when op-sqlite compiles sqlite from sources), in your ",(0,s.jsx)(n.code,{children:"package.json"})," use the following flags:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'"op-sqlite": {\n  "iosSqlite": true\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This means however, you will be used whatever version the phone is running, which might be outdated and it also does not support extension loading. There is no way around this."}),"\n",(0,s.jsx)(n.h2,{id:"libsql",children:"Libsql"}),"\n",(0,s.jsxs)(n.p,{children:["If you want to use expo-updates and libsql at the same time there is one more workaround you need to apply. On your ",(0,s.jsx)(n.code,{children:"AppDelegate"})," (or wherever you initialize your RN view if it's a brownfield integration), you need to call ",(0,s.jsx)(n.code,{children:"[OPSQLite expoUpdatesWorkaround];"})," before initializing the RN view. In case of a normal expo app modify the ",(0,s.jsx)(n.code,{children:"AppDelegate.mm"})," as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-objective-c",children:'#import "OPSQLite.h" // Add the header\n\n@implementation AppDelegate\n\n-(BOOL)application: (UIApplication *)application didFinishLaunchingWithOptions: (NSDictionary *)launchOptions {\n  self moduleName = @"main";\n  self.initialProps = 0{};\n  [OPSQLite expoUpdatesWorkaround]; // Add the call to the workaround\n  return [super application:application didFinishLaunchingWithOptions:launchOptions];\n}\n'})}),"\n",(0,s.jsx)(n.h1,{id:"other",children:"Other"}),"\n",(0,s.jsx)(n.p,{children:"For other conflicts and compilation errors there is no easy solution (Is there a solution?). You need to get rid of the double compilation by hand, either by patching the compilation of each package so that it still builds or removing the dependency on the package."}),"\n",(0,s.jsxs)(n.p,{children:["On Android you might be able to get away by just using a ",(0,s.jsx)(n.code,{children:"pickFirst"})," strategy (here is an ",(0,s.jsx)(n.a,{href:"https://ospfranco.com/how-to-resolve-duplicated-libraries-on-android/",children:"article"})," on how to do that). On iOS depending on the build system you might be able to patch it via a post-build hook, something like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"pre_install do |installer|\n\tinstaller.pod_targets.each do |pod|\n\t\tif pod.name.eql?('expo-updates')\n\t\t\t# Modify the configuration of the pod so it doesn't depend on the sqlite pod\n\t\tend\n\tend\nend\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>r});var o=i(6540);const s={},t=o.createContext(s);function l(e){const n=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);
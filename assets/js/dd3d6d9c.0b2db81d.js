"use strict";(self.webpackChunkop_sqlite=self.webpackChunkop_sqlite||[]).push([[904],{5029:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"ORM_Libs","title":"ORMs & Libs","description":"OP-SQLite is not an ORM. It doesn\'t keep track of entities or creates SQL queries for you. It\'s pretty much a raw bindings to the sqlite3 C api. That being said, ORMs are useful (they make the easy things easier while making the hard things impossible) and there are ORMs that use op-sqlite as their main driver","source":"@site/docs/ORM_Libs.md","sourceDirName":".","slug":"/ORM_Libs","permalink":"/op-sqlite/docs/ORM_Libs","draft":false,"unlisted":false,"editUrl":"https://github.com/OP-Engineering/op-sqlite/blob/main/docs/ORM_Libs.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10},"sidebar":"tutorialSidebar","previous":{"title":"API Reference","permalink":"/op-sqlite/docs/api"},"next":{"title":"C++ Usage","permalink":"/op-sqlite/docs/cpp_usage"}}');var s=t(4848),o=t(8453);const r={sidebar_position:10},a="ORMs & Libs",c={},l=[{value:"DrizzleORM",id:"drizzleorm",level:2},{value:"TypeORM",id:"typeorm",level:2},{value:"PowerSync",id:"powersync",level:2}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"orms--libs",children:"ORMs & Libs"})}),"\n",(0,s.jsx)(n.p,{children:"OP-SQLite is not an ORM. It doesn't keep track of entities or creates SQL queries for you. It's pretty much a raw bindings to the sqlite3 C api. That being said, ORMs are useful (they make the easy things easier while making the hard things impossible) and there are ORMs that use op-sqlite as their main driver"}),"\n",(0,s.jsx)(n.h2,{id:"drizzleorm",children:"DrizzleORM"}),"\n",(0,s.jsx)(n.p,{children:"Drizzle works with op-sqlite. Follow their documentation to set up a new project:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://orm.drizzle.team/docs/connect-op-sqlite",children:"https://orm.drizzle.team/docs/connect-op-sqlite"})}),"\n",(0,s.jsx)(n.p,{children:"Here is a working example"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://github.com/OP-Engineering/op-sqlite-drizzle-example",children:"https://github.com/OP-Engineering/op-sqlite-drizzle-example"})}),"\n",(0,s.jsx)(n.h2,{id:"typeorm",children:"TypeORM"}),"\n",(0,s.jsx)(n.p,{children:"TypeORM is not directly supported as in the past is was broken and people started opening issues on the repo. Here is an example driver you can adjust and pass to the driver param when creating a new TypeORM instance:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { QueryResult, Transaction, open } from '@op-engineering/op-sqlite';\n\nconst enhanceQueryResult = (result: QueryResult): void => {\n  result.rows.item = (idx: number) => result.rows[idx];\n};\n\nexport const typeORMDriver = {\n  openDatabase: (\n    options: {\n      name: string;\n      location?: string;\n      encryptionKey: string;\n    },\n    ok: (db: any) => void,\n    fail: (msg: string) => void\n  ): any => {\n    try {\n      if (!options.encryptionKey || options.encryptionKey.length === 0) {\n        throw new Error('[op-sqlite]: Encryption key is required');\n      }\n\n      const database = open({\n        location: options.location,\n        name: options.name,\n        encryptionKey: options.encryptionKey,\n      });\n\n      const connection = {\n        executeSql: async (\n          sql: string,\n          params: any[] | undefined,\n          ok: (res: QueryResult) => void,\n          fail: (msg: string) => void\n        ) => {\n          try {\n            const response = await database.execute(sql, params);\n            enhanceQueryResult(response);\n            ok(response);\n          } catch (e) {\n            fail(`[op-sqlite]: Error executing SQL: ${e as string}`);\n          }\n        },\n        transaction: (\n          fn: (tx: Transaction) => Promise<void>\n        ): Promise<void> => {\n          return database.transaction(fn);\n        },\n        close: (ok: any, fail: any) => {\n          try {\n            database.close();\n            ok();\n          } catch (e) {\n            fail(`[op-sqlite]: Error closing db: ${e as string}`);\n          }\n        },\n        attach: (\n          dbNameToAttach: string,\n          alias: string,\n          location: string | undefined,\n          callback: () => void\n        ) => {\n          database.attach(options.name, dbNameToAttach, alias, location);\n\n          callback();\n        },\n        detach: (alias: string, callback: () => void) => {\n          database.detach(options.name, alias);\n\n          callback();\n        },\n      };\n\n      ok(connection);\n\n      return connection;\n    } catch (e) {\n      fail(`[op-sqlite]: Error opening database: ${e as string}`);\n    }\n  },\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"powersync",children:"PowerSync"}),"\n",(0,s.jsx)(n.p,{children:"PowerSync uses op-sqlite internally to power their synchronization engine."})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(6540);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);
"use strict";(self.webpackChunkop_sqlite=self.webpackChunkop_sqlite||[]).push([[624],{9362:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"api","title":"API Reference","description":"Open","source":"@site/docs/api.md","sourceDirName":".","slug":"/api","permalink":"/op-sqlite/docs/api","draft":false,"unlisted":false,"editUrl":"https://github.com/OP-Engineering/op-sqlite/blob/main/docs/api.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"Key-Value Storage","permalink":"/op-sqlite/docs/key_value_storage"},"next":{"title":"ORMs & Libs","permalink":"/op-sqlite/docs/ORM_Libs"}}');var s=t(4848),o=t(8453);const i={sidebar_position:9},r="API Reference",l={},c=[{value:"Open",id:"open",level:2},{value:"SQLCipher Open",id:"sqlcipher-open",level:3},{value:"Execute",id:"execute",level:2},{value:"Execute with Host Objects",id:"execute-with-host-objects",level:3},{value:"Prepared statements",id:"prepared-statements",level:2},{value:"Raw execution",id:"raw-execution",level:2},{value:"Multiple Statements",id:"multiple-statements",level:3},{value:"Sync execute",id:"sync-execute",level:3},{value:"Transactions",id:"transactions",level:2},{value:"Batch Execution",id:"batch-execution",level:2},{value:"Blob support",id:"blob-support",level:2},{value:"Loading SQL Dump Files",id:"loading-sql-dump-files",level:2},{value:"Hooks",id:"hooks",level:2},{value:"Database Path",id:"database-path",level:2},{value:"Move assets database",id:"move-assets-database",level:2},{value:"JSONB Support",id:"jsonb-support",level:2},{value:"Loading Extensions",id:"loading-extensions",level:2},{value:"Android",id:"android",level:3},{value:"iOS",id:"ios",level:3},{value:"Loading the extension",id:"loading-the-extension",level:3},{value:"Reactive Queries",id:"reactive-queries",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"api-reference",children:"API Reference"})}),"\n",(0,s.jsx)(n.h2,{id:"open",children:"Open"}),"\n",(0,s.jsxs)(n.p,{children:["You start by opening a connection to your DB. It\u2019s recommended you only open one connection ",(0,s.jsx)(n.strong,{children:"per App session"}),". There is no need to open and close it, as a matter of fact, it will add a lot of latency to your queries."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import { open } from '@op-engineering/op-sqlite';\n\nexport const db = open({\n  name: 'myDb.sqlite',\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"sqlcipher-open",children:"SQLCipher Open"}),"\n",(0,s.jsxs)(n.p,{children:["If you are using SQLCipher all the methods are the same with the exception of the open method which needs an extra ",(0,s.jsx)(n.code,{children:"encryptionKey"})," to encrypt/decrypt the database."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { open } from '@op-engineering/op-sqlite';\n\nexport const db = open({\n  name: 'myDb.sqlite',\n  encryptionKey: 'YOUR ENCRYPTION KEY, KEEP IT SOMEWHERE SAFE', // for example op-s2\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you want to read more about securely storing your encryption key, ",(0,s.jsx)(n.a,{href:"https://ospfranco.com/react-native-security-guide/",children:"read this article"}),". Again: ",(0,s.jsx)(n.strong,{children:"DO NOT OPEN MORE THAN ONE CONNECTION PER DATABASE"}),". Just export one single db connection for your entire application and re-use it everywhere."]}),"\n",(0,s.jsx)(n.h2,{id:"execute",children:"Execute"}),"\n",(0,s.jsx)(n.p,{children:"Base query operation. In runs in a separate so be careful with race conditions. Execution runs on native C++ threads always, so the JS/UI is not blocked, therefore, it\u2019s recommended to ALWAYS use transactions."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { open } from '@op-engineering/op-sqlite';\n\ntry {\n  const db = open({ name: 'myDb.sqlite' });\n\n  let { rows } = await db.execute('SELECT somevalue FROM sometable');\n\n  rows.forEach((row) => {\n    console.log(row);\n  });\n} catch (e) {\n  console.error('Something went wrong executing SQL commands:', e.message);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"execute-with-host-objects",children:"Execute with Host Objects"}),"\n",(0,s.jsxs)(n.p,{children:["It\u2019s possible to return HostObjects when using a query. The benefit is that HostObjects are only created in C++ and only when you try to access a value inside of them a C++ scalar \u2192 JS scalar conversion happens. This means creation is fast, property access is slow. The use case is clear if you are returning ",(0,s.jsx)(n.strong,{children:"massive"})," amount of objects but only displaying/accessing a few of them at the time."]}),"\n",(0,s.jsx)(n.p,{children:"The example of querying 300k objects from a database uses this api. Just be careful with all the gotchas of HostObjects (no spread, no logging, etc.)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"let res = await db.executeWithHostObjects('select * from USERS');\n"})}),"\n",(0,s.jsx)(n.h2,{id:"prepared-statements",children:"Prepared statements"}),"\n",(0,s.jsxs)(n.p,{children:["A lot of the work when executing queries is not iterating through the result set itself but, sometimes, planning the execution. If you have a query which is expensive but you can re-use it (even if you have to change the arguments) you can use a\xa0",(0,s.jsx)(n.code,{children:"prepared statement"}),". Bear in mind most of the benefit of a prepared statement is in the querying, joining and planning on how to retrieve the data, for writes the impact is minimal."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const statement = db.prepareStatement('SELECT * FROM User WHERE name = ?;');\n\n// bind the variables in the order they appear\nawait statement.bind(['Oscar']);\n// Or use the bindsync version\nstatement.bindSync(['Luis']);\nlet results1 = await statement.execute();\n\nawait statement.bind(['Carlos']);\nlet results2 = await statement.execute();\n"})}),"\n",(0,s.jsx)(n.p,{children:"You only pay the price of parsing the query once, and each subsequent execution should be faster."}),"\n",(0,s.jsx)(n.h2,{id:"raw-execution",children:"Raw execution"}),"\n",(0,s.jsx)(n.p,{children:"If you don't care about the keys you can use a simplified execution that will return an array of scalars. This should be a lot faster than the regular operation since objects with the same keys don\u2019t need to be created."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"let result = await db.executeRaw('SELECT * FROM Users;');\n// result = [[123, 'Katie', ...]]\n"})}),"\n",(0,s.jsx)(n.h3,{id:"multiple-statements",children:"Multiple Statements"}),"\n",(0,s.jsx)(n.p,{children:"You can execute multiple statements in a single operation. The API however is not really thought for this use case and the results (and their metadata) will be mangled, so you can discard it. This is not supported in libsql, due to the library itself not supporting this use case."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// The result of this query will all be all mixed, no point in trying to read it\nlet res = await db.execute(\n  `CREATE TABLE T1 (id INT PRIMARY KEY) STRICT;\n  CREATE TABLE T2 (id INT PRIMARY KEY) STRICT;`\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"sync-execute",children:"Sync execute"}),"\n",(0,s.jsxs)(n.p,{children:["You can do sync queries via the ",(0,s.jsx)(n.code,{children:"executeSync"})," functions. Not available in transactions and must be used sparingly as it blocks the UI thread."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"let res = db.executeSync('SELECT 1');\n"})}),"\n",(0,s.jsx)(n.h2,{id:"transactions",children:"Transactions"}),"\n",(0,s.jsx)(n.p,{children:"Wraps the code inside in a transaction. Any error thrown inside of the transaction body function will ROLLBACK the transaction."}),"\n",(0,s.jsxs)(n.p,{children:["If you want to execute a large set of commands as fast as possible you should use the\xa0",(0,s.jsx)(n.code,{children:"executeBatch"}),"\xa0method, it wraps all the commands in a transaction for you and has less overhead. Using prepared statements for writes inside a transaction is discouraged, you gain very little performance when writting to the database and they are not part of the internal lock mechanism of op-sqlite."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"await db.transaction((tx) => {\n  const { status } = await tx.execute(\n    'UPDATE sometable SET somecolumn = ? where somekey = ?',\n    [0, 1]\n  );\n\n  // Any uncatched error ROLLBACK transaction\n  throw new Error('Random Error!');\n\n  // You can manually commit or rollback\n  await tx.commit();\n  // or\n  await tx.rollback();\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"batch-execution",children:"Batch Execution"}),"\n",(0,s.jsx)(n.p,{children:"Allows to execute a batch of commands in a single call. The entire call is wrapped within a transaction, so if any of the statements fail, they all get rolled back."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const commands = [\n  ['CREATE TABLE TEST (id integer)'],\n  ['INSERT INTO TEST (id) VALUES (?)', [1]],\n  [('INSERT INTO TEST (id) VALUES (?)', [2])],\n  [('INSERT INTO TEST (id) VALUES (?)', [[3], [4], [5], [6]])],\n];\n\nconst res = await db.executeBatch(commands);\n\nconsole.log(`Batch affected ${result.rowsAffected} rows`);\n"})}),"\n",(0,s.jsx)(n.p,{children:"In some scenarios, dynamic applications may need to get some metadata information about the returned result set."}),"\n",(0,s.jsx)(n.h2,{id:"blob-support",children:"Blob support"}),"\n",(0,s.jsxs)(n.p,{children:["Blobs are supported via\xa0",(0,s.jsx)(n.code,{children:"ArrayBuffer"})," or typed array (UInt8Array, UInt16Array, etc) directly. Here is an example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"db = open({\n  name: 'blobs',\n});\n\nawait db.execute('DROP TABLE IF EXISTS BlobTable;');\nawait db.execute(\n  'CREATE TABLE BlobTable ( id INT PRIMARY KEY, name TEXT NOT NULL, content BLOB) STRICT;'\n);\n\nlet binaryData = new Uint8Array(2);\nbinaryData[0] = 42;\n\nawait db.execute(`INSERT OR REPLACE INTO BlobTable VALUES (?, ?, ?);`, [\n  1,\n  'myTestBlob',\n  binaryData,\n]);\n\nconst result = await db.execute('SELECT content FROM BlobTable');\n\nconst finalUint8 = new Uint8Array(result.rows[0].content);\n"})}),"\n",(0,s.jsx)(n.h1,{id:"attach-or-detach-other-databases",children:"Attach or Detach other databases"}),"\n",(0,s.jsx)(n.p,{children:"SQLite supports attaching or detaching other database files into your main database connection through an alias. You can do any operation you like on this attached database like JOIN results across tables in different schemas, or update data or objects. These databases can have different configurations, like journal modes, and cache settings."}),"\n",(0,s.jsx)(n.p,{children:"You can, at any moment, detach a database that you don't need anymore. You don't need to detach an attached database before closing your connection. Closing the main connection will detach any attached databases."}),"\n",(0,s.jsx)(n.p,{children:"SQLite has a limit for attached databases: A default of 10, and a global max of 125"}),"\n",(0,s.jsxs)(n.p,{children:["SQLite docs for\xa0",(0,s.jsx)(n.a,{href:"https://www.sqlite.org/lang_attach.html",children:"Attach"}),"\xa0-\xa0",(0,s.jsx)(n.a,{href:"https://www.sqlite.org/lang_detach.html",children:"Detach"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// Follows similar API to the `open` call\ndb.attach({\n  secondaryDbFileName: 'statistics.sqlite', // Filename of the database (JUST THE FILENAME)\n  alias: 'stats', // Alias to be applied to the db\n  location: '../databases', // Path to be prepended to secondaryFileName, in this case full db path: ../databases/statistics.sqlite\n});\n\nconst res = await db.execute(\n  'SELECT * FROM some_table_from_mainschema a INNER JOIN stats.some_table b on a.id_column = b.id_column'\n);\n\n// You can detach databases at any moment\ndb.detach('stats');\n"})}),"\n",(0,s.jsx)(n.h2,{id:"loading-sql-dump-files",children:"Loading SQL Dump Files"}),"\n",(0,s.jsx)(n.p,{children:"If you are trying to load a large set of statements (the larger the more benefit you will see, talking about hundreds of thousands of rows here) or restoring a database backup the fastest way possible will be loading a sqlite dump file. it will be the fastest as there is no back and forth between JS and C++ and SQLite doing all the heavy lifting."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const { rowsAffected, commands } = await db.loadFile(\n  '/absolute/path/to/file.sql'\n);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"hooks",children:"Hooks"}),"\n",(0,s.jsx)(n.p,{children:"You can subscribe to changes in your database by using an update hook:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// Bear in mind: rowId is not your table primary key but the internal rowId sqlite uses\n// to keep track of the table rows\ndb.updateHook(({ rowId, table, operation }) => {\n  console.warn(`Hook has been called, rowId: ${rowId}, ${table}, ${operation}`);\n  const changes = await db.execute('SELECT * FROM User WHERE rowid = ?', [\n    rowid,\n  ]);\n});\n\nawait db.execute(\n  'INSERT INTO User (id, name, age, networth) VALUES(?, ?, ?, ?)',\n  [id, name, age, networth]\n);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Same goes for commit and rollback hooks"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// will fire whenever a transaction commits\ndb.commitHook(() => {\n  console.log('Transaction commmitted!');\n});\n\ndb.rollbackHook(() => {\n  console.log('Transaction rolled back!');\n});\n\n// will fire the commit hook\ndb.transaction(async (tx) => {\n  tx.execute(\n    'INSERT INTO \"User\" (id, name, age, networth) VALUES(?, ?, ?, ?)',\n    [id, name, age, networth]\n  );\n});\n\n// will fire the rollback hook\ntry {\n  await db.transaction(async (tx) => {\n    throw new Error('Test Error');\n  });\n} catch (e) {\n  // intentionally left blank\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"You can pass `null`` to remove hooks at any moment:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"db.updateHook(null);\n\ndb.commitHook(null);\n\ndb.rollbackHook(null);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"database-path",children:"Database Path"}),"\n",(0,s.jsx)(n.p,{children:"Allows to get the file location on disk. Useful for debugging or attaching the file to bug tickets."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const path = db.getDbPath();\n"})}),"\n",(0,s.jsx)(n.h2,{id:"move-assets-database",children:"Move assets database"}),"\n",(0,s.jsxs)(n.p,{children:["Allows to easily move a database from your app bundled assets to the documents folder. You NEED to move databases before using them. The bundle gets replaced every time an app update happens, so changes will get lost otherwise. On Android the app bundle is zipped so you cannot interact with any database on the bundle. If the database has already been created the operation does nothing. Double check you have not created the database before or use ",(0,s.jsx)(n.code,{children:"overwrite"})," to overwrite the existing database on disk."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const copied = await moveAssetsDatabase({\n  filename: 'sample2.sqlite',\n  path: 'sqlite', // The path inside your assets folder on Android, on iOS the file structure is flat\n  overwrite: true, // Always overwrite the database\n});\n\nexpect(copied).to.equal(true);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"jsonb-support",children:"JSONB Support"}),"\n",(0,s.jsxs)(n.p,{children:["Sqlite comes with JSONB support included, no need to load any extension or compilation flag. You should read up on how ",(0,s.jsx)(n.a,{href:"https://fedoramagazine.org/json-and-jsonb-support-in-sqlite-3-45-0/",children:"Sqlite JSONB works"}),". op-sqlite is an (almost) direct binding to sqlite so you need to use the responses as if they would come from sqlite itself. You can insert a string, use JSONB functions and get a string response:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'await db.execute(\'CREATE TABLE states(data TEXT);\');\nawait db.execute(\n  `INSERT INTO states VALUES (\'{"country":"Luxembourg","capital":"Luxembourg City","languages":["French","German","Luxembourgish"]}\');`\n);\nlet res = await db.execute(\n  `SELECT data->>\'country\' FROM states WHERE data->>\'capital\'==\'Amsterdam\';`\n);\nlet res2 = await db.execute(\n  `SELECT jsonb_extract(data, \'$.languages\') FROM states;`\n);\n'})}),"\n",(0,s.jsx)(n.p,{children:"As mentioned in the article you can also use blobs, in either case you need to convert your own data to a string or an ArrayBuffer, this is not done for you."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"let states = // some JS object\n  await db.execute('INSERT INTO states VALUES (?)', [JSON.stringify(states)]);\n// or if using blobs\n\nfunction objectToArrayBuffer(obj) {\n  // Step 1: Serialize the object to a JSON string\n  const jsonString = JSON.stringify(obj);\n\n  // Step 2: Encode the string to UTF-8\n  const encoder = new TextEncoder();\n  const uint8Array = encoder.encode(jsonString);\n\n  // Step 3: Convert Uint8Array to ArrayBuffer\n  return uint8Array.buffer;\n}\n\nawait db.execute('INSERT INTO states VALUES (?)', [\n  objectToArrayBuffer(states),\n]);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"loading-extensions",children:"Loading Extensions"}),"\n",(0,s.jsx)(n.p,{children:"Loading runtime extensions is supported. You need compile your extension to the correct architecture. Each extension has different build process, so you need to figure how to compile it yourself."}),"\n",(0,s.jsx)(n.h3,{id:"android",children:"Android"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Compile your extension to a dynamic library (.so)"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Compile for each common Android architecture, then place them in a folder ",(0,s.jsx)(n.code,{children:"[PROJECT ROOT]/android/app/src/main/jniLibs"}),". That path is special and will automatically be packaged inside your app. It will look something like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"/android\n  /app\n    /src\n      /main\n        /jniLibs\n          /arm64-v8a\n            libcrsqlite.so\n          /armeabi-v7a\n            libcrsqlite.so\n          /x86\n            libcrsqlite.so\n          /x86_64\n            libcrsqlite.so\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"ios",children:"iOS"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Follow the ",(0,s.jsx)(n.a,{href:"https://ospfranco.com/generating-a-xcframework-with-dylibs-for-ios/",children:"Guide to generating iOS dynamic libraries"}),". The process is far more complex, so make sure you follow the steps in detail and create a correct ",(0,s.jsx)(n.code,{children:".xcframework"})]}),"\n",(0,s.jsxs)(n.li,{children:["Unlike Android, iOS does not load the dylib for you automatically, you need to first call ",(0,s.jsx)(n.code,{children:"getDylibPath"})," to get the runtime path of the dylib you created."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"loading-the-extension",children:"Loading the extension"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["On android ",(0,s.jsx)(n.code,{children:"getDylibPath"})," is a no-op and you just need to pass the canonical name of the library. You can then finally call the ",(0,s.jsx)(n.code,{children:"loadExtension"})," function on your database:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'import {open, getDylibPath} from \'@op-sqlite/op-engineering\';\n\nconst db = open(...);\nlet path = "libcrsqlite" // in Android it will be the name of the .so\nif (Platform.os == "ios") {\n  path = getDylibPath("io.vlcn.crsqlite", "crsqlite"); // You need to get the bundle name from the .framework/plist.info inside of the .xcframework you created and then the canonical name inside the same plist\n}\n// Extensions usually have a default entry point to be loaded, if the documentation says nothing, you should assume no entry point change\ndb.loadExtension(path);\n\n// Others might need a different entry point function, you can pass it as a second argument\ndb.loadExtension(path, "entry_function_of_the_extension");\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"reactive-queries",children:"Reactive Queries"}),"\n",(0,s.jsx)(n.p,{children:"Reactive queries have their own section in the docs."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var a=t(6540);const s={},o=a.createContext(s);function i(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);
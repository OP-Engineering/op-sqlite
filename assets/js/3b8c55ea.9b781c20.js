"use strict";(self.webpackChunkop_sqlite=self.webpackChunkop_sqlite||[]).push([[803],{23:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"installation","title":"Installation","description":"Just install and run. In the latest RN versions, pod installation should be automatic but if not run pod install manually.","source":"@site/docs/installation.md","sourceDirName":".","slug":"/installation","permalink":"/op-sqlite/docs/installation","draft":false,"unlisted":false,"editUrl":"https://github.com/OP-Engineering/op-sqlite/blob/main/docs/installation.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","next":{"title":"Configuration","permalink":"/op-sqlite/docs/configuration"}}');var s=i(4848),t=i(8453);const l={sidebar_position:1},a="Installation",r={},d=[{value:"use_frameworks",id:"use_frameworks",level:2},{value:"Compilation clashes",id:"compilation-clashes",level:2},{value:"Expo Updates",id:"expo-updates",level:3},{value:"Libsql and Expo Updates",id:"libsql-and-expo-updates",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"installation",children:"Installation"})}),"\n",(0,s.jsxs)(n.p,{children:["Just install and run. In the latest RN versions, pod installation should be automatic but if not run ",(0,s.jsx)(n.code,{children:"pod install"})," manually."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm i -s @op-engineering/op-sqlite\n"})}),"\n",(0,s.jsx)(n.p,{children:"You cannot use this library on a expo-go app, you need to pre-build your app. No expo plugin is needed, just make sure the pods are properly setup."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npx expo install @op-engineering/op-sqlite\nnpx expo prebuild --clean\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This package only runs on ",(0,s.jsx)(n.code,{children:"iOS"}),", ",(0,s.jsx)(n.code,{children:"Android"})," and ",(0,s.jsx)(n.code,{children:"macOS"}),"."]}),"\n",(0,s.jsx)(n.h1,{id:"configuration",children:"Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["SQLite is very customizable on compilation level. op-sqlite also allows you add extensions or even change the base implementation. You can do this by adding the following to your ",(0,s.jsx)(n.code,{children:"package.json"}),":"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:['[!IMPORTANT]\nWhen using a monorepo, be sure to add the "op-sqlite" config to the monorepo root ',(0,s.jsx)(n.code,{children:"package.json"})," file.\nThis is necessary because the ",(0,s.jsx)(n.code,{children:"node_modules/@op-engineering/op-sqlite/op-sqlite.podspec"})," will search for first the ",(0,s.jsx)(n.code,{children:"package.json"})," file in a parent directory.\nAlternative, you may be able to solve this by blocking this package from being hoisted to the root ",(0,s.jsx)(n.code,{children:"node_modules"}),".\nCheck your ios/Podfile.lock to see where it's being installed."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  // ... the rest of your package.json\n  // All the keys are optional, see the usage below\n  "op-sqlite": {\n    "sqlcipher": false\n    // "crsqlite": false,\n    // "performanceMode": true,\n    // "iosSqlite": false,\n    // "sqliteFlags": "-DSQLITE_DQS=0",\n    // "fts5": true,\n    // "rtree": true,\n    // "libsql": true,\n    // "sqliteVec": true,\n    // "tokenizers": ["simple_tokenizer"]\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"All keys are optional, only turn on the features you want:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sqlcipher"})," allows to change the base sqlite implementation to ",(0,s.jsx)(n.a,{href:"https://www.zetetic.net/sqlcipher/",children:"sqlcipher"}),", which encrypts all the database data with minimal overhead. You will still need to keep your encryption key secure. Read more about security in React Native ",(0,s.jsx)(n.a,{href:"https://ospfranco.com/react-native-security-guide/",children:"here"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"crsqlite"})," is an extension that allows replication to a server backed sqlite database copy. ",(0,s.jsx)(n.a,{href:"https://github.com/vlcn-io/cr-sqlite",children:"Repo here"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"performanceMode"})," turns on certain compilation flags that make sqlite speedier at the cost of disabling some features. You should almost always turn this on, but test your app thoroughly."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"iosSqlite"})," uses the embedded iOS version from sqlite, which saves disk space but may use an older version and cannot load extensions as Apple disables it due to security concerns. On Android SQLite is always compiled from source as each vendor messes with sqlite or uses outdated versions."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sqliteFlags"})," allows you to pass your own compilation flags to further disable/enable features and extensions. It follows the C flag format: ",(0,s.jsx)(n.code,{children:"-D[YOUR_FLAG]=[YOUR_VALUE]"}),". If you are running large queries on large databases sometimes on Android devices you might get a IO exception. You can disable temporary files by using adding the ",(0,s.jsx)(n.code,{children:'"-DSQLITE_TEMP_STORE=2"'})," flag."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"fts5"})," enables the full ",(0,s.jsx)(n.a,{href:"https://www.sqlite.org/fts5.html",children:"text search extension"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tokenizers"})," allows you to write your own C tokenizers. Read more in the corresponding section in this documentation."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"rtree"})," enables the ",(0,s.jsx)(n.a,{href:"https://www.sqlite.org/rtree.html",children:"rtree extension"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sqliteVec"})," enables ",(0,s.jsx)(n.a,{href:"https://github.com/asg017/sqlite-vec",children:"sqlite-vec"}),", an extension for RAG embeddings"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Some combination of features are not allowed. For example ",(0,s.jsx)(n.code,{children:"sqlcipher"})," and ",(0,s.jsx)(n.code,{children:"iosSqlite"})," since they are fundamentally different sources. In this cases you will get an error while doing a pod install or during the Android build."]}),"\n",(0,s.jsx)(n.h1,{id:"conflicts",children:"Conflicts"}),"\n",(0,s.jsx)(n.h2,{id:"use_frameworks",children:"use_frameworks"}),"\n",(0,s.jsxs)(n.p,{children:["In case you are using ",(0,s.jsx)(n.code,{children:"use_frameworks"})," (for example if you are using ",(0,s.jsx)(n.code,{children:"react-native-firebase"}),"), this will break the compilation process and force the compilation to use the embedded sqlite on iOS. One possible workaround is forcing ",(0,s.jsx)(n.code,{children:"op-sqlite"})," to be compiled statically, you can modify the ",(0,s.jsx)(n.code,{children:"Podfile"})," as:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"pre_install do |installer|\n  installer.pod_targets.each do |pod|\n    if pod.name.eql?('op-sqlite')\n      def pod.build_type\n        Pod::BuildType.static_library\n      end\n    end\n  end\nend\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you are using Expo CNG you can use the ",(0,s.jsx)(n.a,{href:"https://github.com/jonshaffer/expo-plugin-ios-static-libraries?tab=readme-ov-file#installation",children:(0,s.jsx)(n.code,{children:"expo-plugin-ios-static-libraries"})})," plugin to automate adding the static setting for op-sqlite"]}),"\n",(0,s.jsxs)(n.p,{children:["It forces static compilation on ",(0,s.jsx)(n.code,{children:"op-sqlite"})," only. Since everything is compiled from sources this ",(0,s.jsx)(n.em,{children:"should"})," work, however do it at your own risk since other compilation errors might arise."]}),"\n",(0,s.jsx)(n.h2,{id:"compilation-clashes",children:"Compilation clashes"}),"\n",(0,s.jsx)(n.p,{children:"If you have other packages that are dependent on sqlite you will have issues. Some of the known offenders are:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"expo-updates"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"expo-sqlite"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"cozodb"})}),"\n",(0,s.jsx)(n.li,{children:"Other packages that try to add/link sqlite (or the sqlite3 cocoapod)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"expo-updates",children:"Expo Updates"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expo-updates"})," now has a added a new way to avoid a hard dependency on sqlite. Adding\xa0",(0,s.jsx)(n.code,{children:'"expo.updates.useThirdPartySQLitePod": "true"'}),"\xa0to\xa0",(0,s.jsx)(n.code,{children:"ios/Podfile.properties.json"}),"\xa0fixes the duplicate symbols and header definition issues when\xa0",(0,s.jsx)(n.code,{children:"expo-updates"}),"\xa0is the only conflicting package."]}),"\n",(0,s.jsx)(n.p,{children:"An expo plugin can also be used:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import type { ConfigPlugin } from '@expo/config-plugins';\nimport { withPodfileProperties } from '@expo/config-plugins';\n\nconst withUseThirdPartySQLitePod: ConfigPlugin<never> = (expoConfig) => {\n  return withPodfileProperties(expoConfig, (config) => {\n    config.modResults = {\n      ...config.modResults,\n      'expo.updates.useThirdPartySQLitePod': 'true',\n    };\n    return config;\n  });\n};\n\nexport default withUseThirdPartySQLitePod;\n"})}),"\n",(0,s.jsx)(n.p,{children:"If you cannot remove the dependency each of the packages will try to compile sqlite from sources or link it on build time. Even if they manage to compile, they might compile sqlite with different compilation flags and you might face runtime errors."}),"\n",(0,s.jsxs)(n.p,{children:["Another workaround for the expo packages, is you can use the iOS embedded version of sqlite for op-sqlite, in your ",(0,s.jsx)(n.code,{children:"package.json"})," turn on the ",(0,s.jsx)(n.code,{children:"iosSqlite"})," flag:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'"op-sqlite": {\n  "iosSqlite": true\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This means however, you will be used whatever version the phone is running, which might be outdated and it also does not support extension loading. There is no way around this."}),"\n",(0,s.jsx)(n.h3,{id:"libsql-and-expo-updates",children:"Libsql and Expo Updates"}),"\n",(0,s.jsxs)(n.p,{children:["If you want to use ",(0,s.jsx)(n.code,{children:"expo-updates"})," and ",(0,s.jsx)(n.code,{children:"libsql"})," at the same time there is one more workaround you need to apply. On your ",(0,s.jsx)(n.code,{children:"AppDelegate"})," (or wherever you initialize your RN view if it's a brownfield integration), you need to call ",(0,s.jsx)(n.code,{children:"[OPSQLite expoUpdatesWorkaround];"})," before initializing the RN view. In case of a normal expo app modify the ",(0,s.jsx)(n.code,{children:"AppDelegate.mm"})," as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-objective-c",children:'#import "OPSQLite.h" // Add the header\n\n// Modify the didFinishLaunchingWithOptions function\n-(BOOL)application: (UIApplication *)application didFinishLaunchingWithOptions: (NSDictionary *)launchOptions {\n  self moduleName = @"main";\n  self.initialProps = 0{};\n\n  // Add the call to the workaround\n  [OPSQLite expoUpdatesWorkaround];\n\n  return [super application:application didFinishLaunchingWithOptions:launchOptions];\n}\n'})}),"\n",(0,s.jsx)(n.h1,{id:"other",children:"Other"}),"\n",(0,s.jsx)(n.p,{children:"For other conflicts and compilation errors there is no documented solutions. You need to get rid of the double compilation by hand, either by patching the compilation of each package so that it still builds or removing the dependency on the package."}),"\n",(0,s.jsxs)(n.p,{children:["On Android you might be able to get away by just ",(0,s.jsxs)(n.a,{href:"https://ospfranco.com/how-to-resolve-duplicated-libraries-on-android/",children:["using a ",(0,s.jsx)(n.code,{children:"pickFirst"})," strategy"]}),". On iOS depending on the build system you might be able to patch it via a post-build hook, something like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"pre_install do |installer|\n\tinstaller.pod_targets.each do |pod|\n\t\tif pod.name.eql?('expo-updates')\n\t\t\t# Modify the configuration of the pod so it doesn't depend on the sqlite pod\n\t\tend\n\tend\nend\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>a});var o=i(6540);const s={},t=o.createContext(s);function l(e){const n=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);